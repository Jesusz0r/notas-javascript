# Funciones del futuro: *generadoras* y *promesas*

Las *generadoras* son un tipo especial de función. Mientras que una función estándar produce como máximo un solo valor cuando es ejecutada (el valor que devuelva *return*), los generadores pueden producir multiples valores, por solicitud, mientras suspenden su ejecución entre solucitudes. Los *generadores* usualmente son considerados "raros" y no son carácteristicas utilizadas por el programador promedio.
Las *promesas* por otro lado, son un nuevo tipo de objeto que nos permite trabajar con código asincrónico. Una *promesa* es un "placeholder" para un valor que todavía no tenemos. Son especialmente buenas para trabajar con multiples pasos asincrónicos.

## Haciendo nuestro código asincrónico elegante con *generadoras* y *promesas*

Imaginemos que necesitamos hacer un pedido a nuestro servidor para obtener una lista de todos nuestros usuarios, su puesto de trabajo y los detalles de dicho puesto. Podríamos lograr esto de la siguiente forma:

```js
try {
    const empleados = syncGetJSON('empleados.json');
    const puestoTrabajo = empleados.map((empleado) => {
        return empleado.puestoTrabajo;
    });
    const detallesTrabajo = syncGetJSON('detalles.json');
} catch(e) {
    // Manejamos el error
}
```

Este código es relativamente fácil de entender y si algún error ocurre, tenemos como manejar dicho error. Pero este código tiene un problema. Obtener datos de el servidor es una operación muy pesada y debido a que JavaScript trabaja solo en un solo hilo de ejecución, con este código hemos bloqueado nuestra aplicación hasta que nuestra operación termine de ejecutarse. Para resolver este problema, podemos escribir nuestro código utilizando *callbacks*, que serán invocadas una vez una tarea termine, sin bloquear la ejecución de nuestro programa.

```js
getJSON('empleados.json', (err, data) => {
    if (err) {
        console.log(err);
        return;
    }

    const puestoTrabajo = empleados.map((empleado) => {
        return empleado.puestoTrabajo;
    });

    getJSON('detalles.json', (err, data) => {
        if (err) {
            console.log(err);
            return;
        }

        // Hacer algo con los datos
    });
})
```

Ahora nuestro código no bloquea la ejecución de nuestro programa, pero es muy difícil de leer, agrega muchas líneas de código para manejar errores que se repiten mucho y simplemente es muy feo. Aquí es donde las *generadoras* y *promesas* son útiles y entran en juego. Combinando ambas, podemos convertir este código en algo más elegante.

```js
async(function*() {
    try {
        const empleados = yield getJSON('empleados.json');
        const puestoTrabajo = empleados.map((empleado) => {
            return empleado.puestoTrabajo;
        });
        const detallesTrabajo = yield getJSON('detalles.json');
    } catch(e) {
        // Hacemos algo con el error
    }
});
```

## Trabajando con funciones *generadoras*

Las funciones *generadoras* son un nuevo tipo de función y son muy diferentes a las estándar. Una función *generadora* es una función que genera una secuencia de valores, pero no todos a la ves, como una función estándar haría. Debemos pedirle explicitamente un nuevo valor y la función *generadora* responderá con un valor o nos notificará que ya no hay ningún valor que producir. Lo más curioso es que luego de que un valor sea producido, una función *generadora* no termina su ejecución, como una función normal haría. En lugar de esto, es suspendida y cuando pidamos otro valor, la función *generadora* resume su ejecución desde donde paró.

```js
// definimos una función generadora utilizando * luego de la palabra function
function* generadora() {
    yield "Hola"; // Generamos valores individuales utilizando la palabra yield.
    yield "Como";
    yield "Estas?";
}

// Utilizamos un ciclo for...of para ejecutar nuestra función generadora
for (let value of generadora()) {
    console.log(value);
}
```

Empezamos definiendo nuestra función *generadora* utilizando * después de la palabra function. Esto nos permite utilizar la nueva palabra *yield* en el cuerpo de la función para producir valores individuales.
Una manera de invocar y consumir los valores de las funciones *generadoras* es utilizando un ciclo *for...of*. Como podemos ver, la función *generadora* no tiene ninguna declaración de retorno *return*. Las funciones *generadoras* son diferentes a las funciones estándar y no necesitan un valor de retorno. Para empezar, invocar una función *generadora* no ejecuta dicha función; en vez de esto, crea un objeto llamado *iterator*.

### Controlando las funciones *generadoras* a través del objeto *iterator*

Invocar una función *generadora* no significa que el cuerpo de dicha función será ejecutado. En vez, un objeto *iterator* es creado, un objeto con el cual nos podemos comunicar con la función *generadora*. Por ejemplo, podemos utilizar el objeto *iterator* para pedir valores adicionales.

```js
// Definimos una función generadora que producira dos valores.
function* generadora() {
    yield "Hola"; 
    yield "Chao";
}

const iterador = generadora(); // invocamos nuestra función generadora lo que creará un objeto iterator
const hola = iterador.next(); /* invocar el método next() en un objeto iterator retorna un objeto que contiene el valor de yield y una propiedad que nos dice si la función generadora ha terminado su ejecución o no. */
console.log(hola); // { value: "Hola", done: false }
const chao = iterador.next(); /* la segunda vez que invocamos el método next nos devuelve el segundo valor */
console.log(chao); // { value: "Chao", done: false }
const done = iterador.next(); // ya no tenemos ningún otro valor, así que devuelve un objeto con value undefined y done true
console.log(done); // { value: "undefined", done: true }
```

Como hemos visto, cuando invocamos una función *generadora*, un nuevo objeto *iterator* es creado. Dicho objeto es utilizado para controlar la ejecución de la función *generadora*. Una de la cosas fundamentales que expone el objeto *iterator* es el método *next* que es usado para controlar cuando queremos pedir un nuevo valor a la función *generadora*.
Cuando ejecutamos una función *generadora* utilizando el método next, el código de dicha función se ejecuta hasta que alcanza la palabra *yield* y retorna un objeto que contiene la propiedad value y done, una contiene el valor y la otra contiene el estado que muestra si la función generadora aún puede ejecutarse o si ya está finalizada.
Tan pronto como el nuevo valor es retornado, la función *generadora* suspende su ejecución y espera a que pidamos otro valor utilizando el método next. Esta es una característica muy poderosa que las funciones estándar no tienen.

En el ejemplo anterior, primero invocamos la función *generadora* la cual produce un objeto *iterator* y el cual almacenamos en la variable *iterador*, luego, utilizamos dicho objeto para manejar la ejecución de nuestra función *generadora*. Al hacer la primera llamada a nuestra función *generadora* utilizando el objeto *iterador* y el método next nos retorna otro objeto que contiene como propiedades el valor de la primera palabra *yield* y el estado de la función *generadora*, luego la función vuelve a un estado de suspención. La segunda llamada a next despierta la función de su estado de suspención y nos retorna otro objeto que contiene como propiedades el valor de la segunda palabra *yield* y el estado de la función *generadora*, luego la función vuelve a su estado de suspención. La tercera llamada a next despierta la función de su estado de suspención y nos retorna un objeto con la propiedad value vacía y la propiedad done con valor true, lo que significa que nuestra función *generadora* ha terminado de ejecutarse.

#### Iterando el iterador

El objeto *iterator*, creado cuando invocamos la función *generadora*, expone el método next con el cual podemos pedir nuevos valores de la función *generadora*. El método next retorna un objeto que contiene el valor producido por la función generadora, así como también la propiedad done que nos dice si la función *generadora* aún tiene valores por producir.

```js
// crea la función generadora
function* generadora() {
    yield "Hola";
    yield "Chao";
}

const iterador = generadora(); // crea un objeto iterator
let item; // crea una variable en la cual almacenaremos los valores generados en cada ciclo por la función generadora

/* En cada iteración, pedimos un valor de la función generadora y lo almacenamos el la variable item. Paramos la ejecución cuando la propiedad done del objeto almacenado en la variable item pase a ser true , lo que significaría que la función generadora ya no tiene más valores para producir. */ 
while(!(item = iterador.next()).done) {
    console.log(item.value);
}
```

En cada iteración de nuestro loop, pedimos un valor al *generador* llamando el método *next* de nuestro *iterador*, almacenamos ese valor en la variable item. Todos los objetos almacenados en la variable item en cada loop tienen una propiedad *value* que almacena el valor que retornó la *función generadora* y una propiedad *done* que nos dice si la función ha terminado de producir valores. Si la *función generadora* no ha terminado de producir valores, entonces seguimos en nuestro ciclo while, si ya terminó, paramos nuestro ciclo.

#### Cediendo valores a otras *funciones generadoras*

Así como llamamos funciones estándar desde otras funciones estándar, en algunos casos queremos delegar la ejecución de un *generador* a otro.

```js
function* saludos() {
    yield 'Hola';
    yield* despedidas(); // delegamos este yield a otra función generadora
}

function* despedidas() {
    yield 'Chao';
    yield 'Adios';
}

for (let saludo of saludos()) {
    console.log(saludo);
}
```

Si ejecutamos el código anterior, veremos que aparece en consola Hola, Chao y Adios. Hola es el primer valor que retorna la *función generadora* saludos. Al usar "yield* " en un *iterador* delegamos otra *función generadora* a dicho *yield*. En este ejemplo, desde la función saludo estamos delegando la función despedidas, todas las invocaciones al método *next* del *iterador* son dirigidas a la *función generadora* despedidas. Solo cuando la función despedidas ya no tiene ningún valor que devolver, la función saludos continuará su ejecución y mostrará el resto de valores (si hay alguno). El ciclo *for...of* sigue invocando el método *next* hasta que retorne *done: true*, da igual a que *función generadora* estemos haciendo referencia.

### Usando *funciones generadores*

#### Usando *funciones generadoras* para generar IDs

A la hora de crear ciertos objetos, muchas veces necesitamos asignarles un ID único a cada objeto. La forma más sencilla de hacer esto es a través de una variable global que almacene el último valor asignado, pero hacer eso no es muy práctico ya que la variable podría ser reasignada accidentalmente. Otra opción sería utilizar una *función generadora*.

```js
// Definimos una función generadora
function* generadoraId() {
    let id = 0; /* Creamos una variabl que lleve un seguimiento del ID (Esta variable no puede ser modificada fuera de nuestra función generadora). */

    // Ciclo que genera una secuencia infinita de IDs
    while(true) {
        yield ++id;
    }
}

const iteradorId = generadoraId();
const obj1 = { id: iteradorId.next().value }; // id: 1
const obj2 = { id: iteradorId.next().value }; // id: 2
const obj3 = { id: iteradorId.next().value }; // id: 3
```

En este ejemplo empezamos declarando una *función generadora* que tiene una variable local que lleva un seguimiento de último ID asignado. Esa variable es local de nuestar *función generadora* y no puede ser modificada desde afuera de esta, así que no hay riesgo de que accidentalmente modifiquemos su valor. Luego creamos un ciclo *while* infinito, que a cada llamada al método *next* hará un ciclo y luego detendrá su ejecución hasta la próxima llamada al método *next*.

*Nota: Escribir loops infinitos no es algo que generalmente hagamos en funciones estándar. Pero con **funciones generadoras**, todo está bien. Cada ves que encuentra una declaración **yield**, la ejecución de la **función generadora** es suspendida hasta que invoquemos el método **next** de nuevo. Así que cada llamada a **next** ejecuta un solo ciclo del ciclo **while** y retorna el nuevo ID.*

Luego de definir la *función generadora* creamos un *iterador* y lo almacenamos en la variable iteradorId.
Esto nos permite tener control de nuestra *función generadora* y así podemos realizar llamadas al método *next*, que ejecuta la *función generadora* hasta que la declración *yield* es encontrada y retorna un nuevo valor ID que podemos utilizar para asignarle un ID único a nuestros objetos.

#### Utilando *funciones generadoras* para manipular el DOM

El DOM es una parte fundamental en el desarrollo web y mucho de nuestro código está encargado de recorrerlo para luego manejarlo. Podemos utilizar *funciones generadoras* para atravesar los elementos del DOM.

```js
function* DOMTraversal(element) {
    yield element;
    element = element.firstChildElement;
    while (element) {
        yield* DOMTraversal(element); /* Utilizamos yield* para transferir el control de la iteración a otra instancia de la función generadora DOMTraversal */
        element = element.nextElementSibling;
    }
}

const subTree = document.getElementById("subTree");
// Iteramos sobre los nodos de nuestro elemento del DOM utilizando un ciclo for...of
for (let element of DOMTraversal(subTree)) {
    console.log(element.nodeName);
}
```

El ejemplo anterior muestra como podemos atravesar los elementos del DOM utilizando *funciones generadoras*. Creamos una *función generadora* en cada nodo visitado y hacemos un *yield* a dicho nodo. El beneficio de esta sintáxis es que consumimos la secuencia de nodos generados con un simple ciclo *for...of*. Este ejemplo también es bueno para demostrar como separar código que produce valores (en este caso, nodos HTML) del código que consume la secuencia de valores generados (el ciclo for...of), sin tener que utilizar *callbacks*.

### Comunicandonos con las *funciones generadoras*

En los ejemplos vistos hasta ahora, hemos visto como retornar múltiples valores de una *función generadora* utilizando *yield*. Pero las *funciones generadoras* son incluso más poderosas que eso. También podemos enviar datos a una *función generadora*, de esta forma tenemos una comunicación por ámbos lados. Gracias a esto podemos producir resultados, hacer algo con esos resultados desde afuera de la *función generadora* y luego volver a enviarle esos datos a la *función generadora* para que continue su ejecución con los nuevos datos.

#### Enviando valores como argumentos a las *funciones generadoras*

La manera más sencilla de enviar datos a una *función generadora* es tratandola como cualquier otra función y pasarle argumentos.

```js
function* saludos(nombre) {
    const saludo = yield ("Hola " + nombre);
    yield "Hola " + saludo;
}

const saludar = saludos('Jesus');
console.log(saludar.next().value);
console.log(saludar.next('Alberto').value);
```

Una función que recibe datos no es nada especial pero las funciones generadoras tienen el poder de ser pausadas y reanudadas. Y resulta que las *funciones generadoras* pueden recibir data incluso después de que su ejecución haya empezado, cuando reanudemos su ejecución usando el método *next*.

#### Usando el método *next* para enviar valores al *generador*

Además de poder pasar argumentos a las *funciones generadoras* cuando las invocamos por primera vez, también podemos enviar datos al *generador* pasando *argumentos* al método *next*. En el proceso, reanudamos la ejecución de la *función generadora*. El valor pasado es usado por el generador como el valor de **toda** la expresión *yield* en la cual fue suspendida la ejecución de la *función generadora*.
En el ejemplo anterior, primero invocamos la *función generadora* con el valor 'Jesus' como argumento, en ese instante, el primer valor de *yield* es 'Hola Jesus', luego cuando invocamos el método *next* recibimos ese valor y la *función generadora* suspende su ejecución, al invocar el método *next* de nuevo con un argumento, **la expresión completa yield ("Hola " + nombre);** es sustituida por el parámetro que hemos pasado como argumento al método *next*, ahora el valor "Alberto" está almacenado en la variable constante *saludo*, finalmente, cuando la *función generadora* reanuda su ejecución, recibimos como respuesta el siguiente valor de *yield* que sería "Hola " + saludo;

*Nota: Cuando pasamos un argumento al método next, este sustituirá el valor del yield en el que fue suspendida la función generadora, si no hay ningún yield, no podemos asignarle valores a nada. Por este motivo no podemos pasar argumentos a la primera llamada del método next (ya que en la primera llamada al método next no hay ningún valor yield esperando ser reanudado). Si queremos pasar un argumento en la primera llamada al método next, debemos hacerlo cuando invocamos la función generadora por primera vez.*

#### Explorando las *funciones generadoras* detrás de cámaras

Hasta ahora hemos descubierto que invocar una *función generadora* no la ejecuta si no que crea un *iterador* que podemos usar para pedirle nuevos valores a la *función generadora*. Después de que una *función generadora* produce un nuevo valor (usando *yield*), suspende su ejecución y espera por una nueva llamada *next*. En una forma, podríamos decir que una *función generadora* es una máquina que se mueve a través de estados.

+ **Estado suspendido:** Cuando la función generadora es creada empieza en este estado. Ningún código dentro de la *función generadora* es ejecutado.
+ **Ejecución:** El estado en el cual el código de la *función generadora* es ejecutado. La ejecución continua ya sea desde el comienzo o desde donde la *función generadora* fue suspendida por ultima vez. La función se mueve a este estado cuando el método *next* es invocado y existe código que puede ser ejecutado.
+ **Yield suspendido:** Durante la ejecución, cuando una *función generadora* alcanza una expresión *yield*, crea un nuevo objeto que contiene una propiedad *value*, retorna dicho objeto y suspende su ejecución. Este es el estado en el que la *función generadora* es suspendida y queda esperando la invocación del método *next* para continuar con su ejecución.
+ **Completada:** Si durante la ejecución la *función generadora* encuentra un *return* o se queda sin código que ejecutar, la *función generadora* completa su ejecución.

#### Rastreando *funciones generadoras* en el *contexto de ejecución*.

Aunque de algún modo son funciones especiales, las *funciones generadoras* son funciones, así que veamos su relación con el *contexto de ejecución*.

```js
function* saludos(nombre) {
    yield "Hola " + nombre;
    return "Adiós " + nombre;
}

const saludar = saludos("Jesus");
const saludo = saludar.next();
const despedida = saludar.next();
```

Hemos creado nuestra *función generadora* sencilla, ahora exploremos el estado de nuestra aplicación, el *stack* de ejecución y varios puntos en la ejecución de la aplicación.
    + Debido a que estamos ejecutando código global, el *stack* de ejecución contiene solo el contexto de ejecución global, el cual hace referencia el *ambiente global* donde nuestros identificadores son creados. Solo el identificador saludar existe y hace referencia a nuestra *función generadora*.
    + Cuando invocamos la *función generadora* el control de flujo entra en la función y como sucede cuando ejecutamos cualquier otra función, un *contexto de ejecución^* de función es creado y agregado al *stack* de ejecución. Pero debido a que las *funciones generadoras* son funciones especiales, esta no es ejecutada. Por otro lado, un nuevo *iterador* es creado, el cual hemos almacenado en la variable saludar. Como el *iterador* es usado para controlar la ejecución de la *función generadora*, el *iterador* obtiene una referencia del *contexto de ejecución* en el cual fue creado.

Algo interesante sucede cuando el programa suspende la ejecución y se sale de la *función generadora*. Siempre que nuestro programa retorna un valor en una función estándar, el *contexto de ejecución* creado y que pertenece a dicha función es eliminado de stack definitivamente. En el caso de las *funciones generadoras*, son sacadas del stack pero se mantiene viva gracias a que el *iterador* creado cuando se ejecutó la *función generadora* por primera vez mantiene una referencia a esta. Se podría ver como un closure, pero en vez de mantener una referencia a las variables, se mantiene una referencia a el *contexto de ejecución* de la *función generadora*, de este modo se puede reanudar su ejecución cuando invocamos el método next de nuevo.

Otra cosa interesante sucede cuando invocamos el método *next* en el *iterador*: Si estuviesemos invocando una función estandar, causaría la creación de un nuevo *contexto de ejecución*, el cual sería introducido al *stack* de ejecución. Pero como habrás notado, las *funciones generadoras* son cualquier cosa menos estándar, y una llamada al método *next* se comporta de manera muy distinta. Una llamada al método next reactiva el *contexto de ejecución* de la *función generadora* y lo pone al principio del *stack* de ejecución, continuando la ejecución desde el punto en el que fue suspendida. Esto permite suspender y reanudar la ejecución de *funciones generadoras* cuando deseemos.

# Trabajando con *Promesas*

En JavaScript dependemos mucho de computaciones asincrónicas, computaciones cuyos resultados no tenemos aún pero que tendremos en un futuro próximo. ES6 ha introducido un nuevo concepto para manejar las operaciones asincrónicas de una manera más sencilla: *promsesas*.
Una *promesa* es un "espacio reservado" para un valor que no tenemos aún pero que tendremos en un futuro; está garantizado que eventualmente tendremos el valor de una computación asincrónica. Si nuestra *promesa* a ido bien, el resultado será un valor. Si ha ido mal, el resultado será un error. Un buen ejemplo de usar *promesas*, es el de pedir datos a un servidor; hacemos una *promesa* de que eventualmente obtendremos los datos, pero siempre hay una posibilidad de que ocurra un problema.

```js
/* Creamos una promesa utilizando la función constructora de promesas y le
pasamos una función callback con dos parámetros resolve y reject. */
const promesa = new Promise((resolve, reject) => {
    resolve('Esta es una promesa'); // La promesa se resuelve satisfactoriamente
});

/* Para ejecutar una promesa, utilizamos el nombre del identificador
y el método .then, que recibe en un argumento los datos que hemos pasado
cuando resolvimos la promesa */
promesa.then(data => {
    console.log('Data');
/* Luego si hay algún error, usamos el método catch, para recibir
cualquier error que hayamos pasado junto al parámetro reject a la
hora que rechazamos la promesa cuando la creamosx. */
}).catch(err => {
    console.log(err);
})
```

Para crear una *promesa* utilizamos la nueva *función constructora Promise*, al cual le pasamos una función callback (en este caso una *función flecha*). Esta función, llamada *función ejecutora*, tiene dos parámetros: *resolve* y *reject*. La *función ejecutora* es invocada inmediatamente cuando construimos el objeto de la *promesa*, luego invocamos manualmente el parámetro *resolve* si queremos que nuestra *promesa* se resuelva satisfactoriamente o *reject* si queremos que nuestra *promesa* retorne un error.
La *promesa* es ejecutada cuando llamamos el método *then* en dicha *promesa*, este método acepta una *función callback* que se ejecutará si nuestra *promesa* se resolvió satisfactoriamente y recibirá los datos que pasemos como argumento a *resolve* (si pasamos alguno). Luego el método *catch* se ejecutará si la *promesa* ha retornado algún error y recibirá el error que hayamos pasado como argumento a *reject*.

### Entendiendo los problemas de las *funciones callback*

Usamos código asincrónico por que no queremos bloquear la ejecución de nuestra aplicación cuando ejecutamos tareas que tardan mucho en ejecutarse. Actualmente resolvemos este problema utilizando *funciones callback*: a una tarea que tardará mucho en completarse le pasamos una *función callback* que es invocada una vez la tarea haya finalizado.
Por ejemplo, pedir un archivo JSON a nuestro servidor es una tarea que tarda mucho en ejecutarse (dependiendo del tamaño del archivo) y no queremos que nuestra aplicación se paralize y espere por los resultados.

```js
getJSON('/data.json', function callback(err, data) {
    if (err) throw new Error('Un error ha sucedido');
    /* Código */
});
```

Naturalmente, durante la ejecución de este código pueden suceder errores. La única forma de verificar errores dentro de una *función callback* es utilizando un *if* que verifique si recibimos los datos o no, si tuviesemos muchas *funciones callback* y quisieramos verificar si hay errores en cada una de ellas, nuestro código se volvería un desastre.
Además de esto, generalmente luego de que realizamos una tarea que tarda mucho queremos hacer algo con los datos recibidos. Esto podría ser, ejecutar otra tarea que tarde mucho y así sucesivamente, lo que nos llevaría a una serie de invocaciones de *funciones* y *funciónes callback* que generalmente se conoce como la pirámide del infierno.

```js
getJSON('/data1.json', function callback(err, data1) {
    if (err) throw new Error('Un error ha sucedido');
    /* Código */
    getJSON('/data2.json', function callback(err, data2) {
        if (err) throw new Error('Un error ha sucedido');
        /* Código */
        getJSON('/data3.json', function callback(err, data3) {
            if (err) throw new Error('Un error ha sucedido');
            /* Código */
            manageData(function callback(err, managedData) {
                if (err) throw new Error('Un error ha sucedido');
                /* Código */
            });
        });
    });
});
```

Quizás alguna vez hayas terminado con una estructura de código similar a esta, un montón de *funciones callbacks* que son muy difíciles de entender y los errores son muy difíciles de manejar.
Es verdad que hay diferentes librerías que solucionan algunos de estos problemas, pero la gente de JavaScript ha solucionado esto creando las *promesas*, una forma estándar de manejar computaciones asincrónicas.

### Entrando a fondo en *promesas*

Una *promesa* es un objeto que sirve para "reservar un espacio" para un valor que será retornado de una llamada asincrónica. Representa un valor que no tenemos pero que esperamos obtener en un futuro, por esta razón, durante su ciclo de vida, una *promesa* puede entrar en diferentes estados.
Una *promesa* empieza en el estado *pending* (pendiente), en el cual no sabemos nada de nuestro valor "prometido". Es por esto que las *promesas* en este estado son llamadas *promesas no resueltas*. Durante la ejecución de nuestra aplicación, si la función *resolve* de la *promesa* es invocada, la *promesa* pasa al estado "cumplido", en el cual hemos obtenido el valor "prometido" satisfactoriamente. Por otro lado, si la función *reject* es invocada, o si un error no manejado ocurre durante la ejecución de la *promesa*, esta pasa al estado *rechazado*, en el cual no hemos podido obtener el valor "prometido". Una vez la *promesa* haya alcanzado el estado "cumplido" o "rechazado", ya no puede cambiar de estado. Podemos decir que la *promesa* ha sido "resuelta", ya sea satisfactoriamente o no.

```js
const promesa = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('Esta promesa se ha resuelto en 1 segundo');
    }, 1000);
});

promesa.then((data) => {
    console.log(data); // Esta promesa se ha resuelto en 1 segundo
});

const promesaInmediata = new Promise((resolve, reject) => {
    // Resuelve la promesa inmediatamente con la función resolve.
    resolve('Esta promesa se ha resuelto inmediatamente');
});

promesaInmediata.then((data) => {
    console.log(data); // Esta promesa se ha resuelto inmediatamente
});
```

Primero creamos una *promesa*, dentro de esta simularemos una llamada asincrónica que tardará 1 segundo y luego resolverá la *promesa* utilizando la función *resolve*. Después ejecutamos la *promesa* utilizando el método *then*.
Segundo creamos una *promesa*, esta la resovleremos inmediatamente llamando la función *resolve*. Ejecutamos dicha *promesa* utilizando el método *then*.

Si ejecutamos el código anterior, veremos que se mostrará en nuestra consola el mensaje "Esta promesa se ha resuelto inmediatamente" y después de 1 segundo se mostrará el mensaje "Esta promesa se ha resuelto en 1 segundo".
Las *funciones callback* pasadas como argumento al método *then* siempre se ejecutará de forma asincrónica, da igual el estado actual de la *promesa*.

*Nota: las promesas están diseñadas para manejar tareas asincrónicas, así que el motor de JavaScript siempre recurre al manejo asincrónico de nuestro código para hacer que el comportamiento de las promesas sea predictivo. El motor de JavaScript ejecuta las funciones callback del método then después de que todo el código en el event loop haya sido ejecutado y sacado del loop. Esto significa que si hay código ejecutandose y nuestra promesa es resuelta, el código dentro de la función callback no es ejecutado hasta que el código que actualmente se está ejecutando finalice.*

### Rechazando *promesas*

Hay dos maneras de rechazar *promesas*, explicitamente, al llamar el parámetro pasado *reject* o implicitamente, si durante la ejecución de una *promesa* una excepción no manejada ocurre.

```js
const promesa = new Promise((resolve, reject) => {
    reject("Rechazando una promesa explicitamente"); // Rechazamos la *promesa* ejecutando el parámetro reject.
});

promesa.then(fallo => {
    console.log('El then no será llamado por que la promesa falló');
}).catch(err => {
    console.log(err); // mostrará Rechazando una promesa explicitamente
});
```

Cuando se rechaza una *promesa* ya sea explicita o implicitamente, el método *then* no es ejecutado, en vez, se ejecuta la segunda *función callback* o el método *catch*.

```js
const promesa = new Promise((resolve, reject) => {
    variableNoDeclarada++; // Esta variable no existe, lo que provocará un error no manejado y rechazará la promesa.
});

promesa.then(fallo => {
    console.log('El método then no será invocado por que la promesa falló');
}).catch(err => {
    console.log(err.message); // Mostrará el mensaje del error (variableNoDeclarada is not defined).
});
```

Dentro del cuerpo de la *promesa* intentamos incrementar una variable que no existe. Como es de esperar, esto resulta en una excepción. Debido a que no hay una declaración *try-catch* para manejar la excepción, esto resulta en una excepción no manejada, lo cual hace que nuestra *promesa* sea rechazada implicitamente y el método *catch* sea invocado.
Esta forma de manejar problemas que suceden cuando trabajamos con *promesas* resulta muy útil. Sin importar como la *promesa* haya sido rechazada, ya sea explicita o implicitamente, si una excepción ocurre, todos los errores son pasados y nuestro método *catch* es invocado (incluso si hay múltiples métodos *then*, si uno falla, dicho error es pasado al método *catch*). Lo que hace que manejar errores sea mucho más sencillo.
Ahora que sabemos como funcionan las *promesas* veamos como se implementaría en un caso real.

### Creando nuestra primera *promesa* "real"

Una de las operaciones asincrónicas más común es la de pedirle datos a un servidor. Este es un buen caso para estudiar las *promesas*.

```js
function obtenerJSON(url) {
    //Creamos y retornamos una nueva promesa
    return new Promise((resolve, reject) => {
        //Creamos una llamada AJAX
        const request = new XMLHttpRequest();

        //Inicializamos la llamada AJAX
        request.open('GET', url);

        //Registramos la función que será ejecutada cuando nuestra llamada AJAX haya cargado
        request.onload = function() {
            //Intentamos parsear el JSON recibido
            try {
                //Verificamos si obtubimos una respuesta OK del servidor al hacer la llamada AJAX
                if (this.status === 200) {
                    //Resolvemos la promesa con el JSON parseado
                    resolve(JSON.parse(this.response));
                } else {
                    //Si no recibimos una respuesta OK del servidor rechazamos la promesa con el estado y el texto del error
                    reject(this.status + ' ' + this.statusText);
                }
                //Si no pudimos parsear el JSON rechazamos la promesa
            } catch(e) {
                reject(e.message);
            }
        }

        //Registramos la función que será ejecutada si sucede algún error en nuestra llamada AJAX
        request.onerror = function() {
            // Rechazamos la promesa
            reject(this.status + ' ' + this.statusText);
        }

        //Enviamos la llamada AJAX al servidor
        request.send();
    });
}

//Ejecutamos nuestra promesa
obtenerJSON('data.json').then(data => {
    //Si todo fue bien recibimos los datos como argumentos del método then
    console.log(data);
}).catch(error => {
    //Si no fue bien recibimos un error como argumento del método catch
    console.log(error);
});
```

Nuestro objetivo es crear una función que realice una llamada AJAX al servidor y retorne una *promesa* para poder ejecutar nuestro código de forma asincrónica. Para cumplir con dicho objetivo utilizamos el objeto *XMLHttpRequest* que nos permite hacer pedidos AJAX al servidor y que nos ofrece dos eventos: *onload* y *onerror*. El evento *onload* se ejecuta cuando el navegador recibe una respuesta del servidor y *onerror* se ejecuta cuando sucede un error con la comunicación. Esos eventos pueden ser llamados de manera asincrónica por el navegador.
Si un error con la comunicación sucede, definitivamente no podremos obtener nuestros datos del servidor, por lo que rechazamos la *promesa*.
Si obtenemos una respuesta del servidor, debemos analizar dicha respuesta ya que el servidor puede responder de distintas maneras dependiendo de si se ejecuto satisfactoriamente el pedido AJAX o no. Si en nuetro caso la respuesta no tiene el código 200, rechazamos la *promesa* por que no obtuvimos los datos correctamente. Incluso si el servidor ha respondido satisfactoriamente, esto no significa que hayamos recibido los datos correctos. Debido a que nuestro objetivo era obtener datos JSON del servidor, dicho JSON podría tener errores y es por eso que envolvemos el método *JSON.parse* en una declaración *try-catch*, si parsea satisfactoriamente el archivo JSON, entonces resolvemos la *promesa*, si no parsea el archivo JSON, rechazamos la *promesa* con el error que obtuvimos.

En este caso podemos obtener errores de 3 fuentes distintas: errores estableciendo la conexión con el servidor, el servidor respondiendo con datos no anticipados y código JSON inválido. Podemos manejar estos errores de forma sencilla y en un solo sitio gracias a la *promesa* que hemos creado.

### Concatenando *promesas*

Hemos visto como manejar multiples computaciones asincrónicas utilizando *funciones callback* generan la "piramide del infierno", una secuencia de *callbacks* anidadas una dentro de otras y que hacen que nuestro código se vea muy desorganizado y sea difícil de leer.
También hemos visto como funcionan las *promesas* y que si utilizamos el método *then* en ellas podemos registrar una *funcion callback* que se ejecutará cuando dicha *promesa* sea resuelta satisfactoriamente. Lo que aún no hemos visto es como concatenar multiples computaciones asincrónica utilizando *promesas*. El método *then* retorna otra *promesa*, lo que nos permite concatenar múltiples llamadas asincrónicas utilizando el método *then*.

```js
obtenerJSON('data.json')
.then(data => obtenerJSON('data2.json'))
.then(data2 => obtenerJSON('data3.json))
.then(data3 => {
    console.log('Hemos obtenido todos los datos satisfactoriamente');
})
.catch(err => {
    console.log(err); // Manejamos los errores que puedan ocurrir en cualquier computación dentro de los métodos then
});
```

Hemos creado una secuencia de *promesas* que serán (si todo va bien) resueltas una tras otra. Primero, invocamos la función getJSON para obtener datos del servidor. Cuando hayamos recibido dichos datos, la *promesa* es resuelta y ejecuta el método *then* siguiente. Una vez hayamos recibido los datos, la *promesa* es resuelta de nuevo, el siguiente método *then* es ejecutado y así sucesivamente hasta terminar la ejecución de todos los métodos *then* o que suceda algún error y este sea recibido por el método *catch*.

#### Manejando errores en *promesas* concatenadas

Cuando trabajamos con una secuencia de pasos asincrónicos, puede ocurrir un error en alguno de estos pasos, sabemos que podemos proporcionar una *función callback* como último argumento al método *then* o utilizar el método *catch* para manejar errores. Si un error sucede en alguno de los métodos *then*, el método *catch* es invocado y la *promesa* termina su ejecución. De esta forma nuestro código es más limpio y legible.

### Esperando la ejecución de un número de *promesas*

Además de ayudarnos a manejar una serie de pasos asincrónicos, las *promesas* también nos ayudan a reducir la espera por un número específico de llamadas asincrónicas. 

```js
/*Promise all recibe un array de promesas y crea una nueva promesa que es resuelta si todas las promesas en el array se ejecutaron satisfactoriamente */
Promise.all([
    getJSON('data.json'),
    getJSON('data1.json'),
    getJSON('data2.json')
]).then(resultado => {
    var resultado1 = resultado[0], resultado2 = resultado[1], resultado3 = resultado[2];
    //Este mensaje se va a mostrar una vez todas las promesas hayan sido ejecutadas
    console.log('Hemos ejecutado todas nuestras promesas satisfactoriamente');
}).catch(err => {
    console.log(err.message);
});
```

Como podemos ver, no tenemos que preocuparnos por el orden en el cual las tareas asincrónicas son ejecutadas o si algunas finalizan mienstras que otras no. Declaramos que queremos esperar un número de *promesas* utilizando el método *Promise.all*. Este método recibe un array de *promesas* y crea una nueva *promesa* que se resuelve satisfactoriamente cuando todas las *promesas* en el array se hayan resuelto satisfactoriamente o es rechazada si ha ocurrido algún error en alguna de las *promesas* del array. La *función callback* que recibe el método *then* de *Promise.all* recibe un array que contiene el resultado de cada una de las *promesas* pasadas como argumento a *Promise.all*, en orden. 

#### Carrera de *promesas*

Cuando tenemos un grupo de *promesas* y queremos ejecutar algún código cuando cualquiera de esas *promesas* sea resuelta (no importa cual sea resuelta primero), podemos utilizar el método *Promise.race*

```js
Promise.race([
    getJSON('data1.json'),
    getJSON('data2.json'),
    getJSON('data3.json')
]).then(data => {
    /*Se ejecutará cuando cualquiera de las promesas pasadas como argumento se haya resuelto (la primera que se resuelva)*/
    console.log('Se ha resuelto una promesa');
}).catch(err => {
    console.log(err);
});
```

Usamos *Promise.race* cuando queremos ejecutar código cuando cualquiera de las *promesas* pasadas como argumento se resuelva, ya sea satisfactoriamente o no.

Hasta ahora hemos visto como funcionan las *promesas* y como las podemos utilizar para realizar una serie de computaciones asincrónicas, ya sea en serie o en paralelo. Hemos visto el beneficio que tiene su uso en comparación con el uso de *funciones callback* en términos de manejo de errores y simplicidad de código.

## Combinando *funciones generadoras* y *promesas*

La capacidad de las *funciones generadoras* para pausar y reanudad el código de una función en conjunto con el uso de *promesas* nos permite escribir un código más elegante. Como sabemos, al utilizar la palabra *yield* pausamos la ejecución de una *función generadora* sin bloquear la ejecución de nuestro programa. Para reanudad la ejecución de la *función generadora* utilizamos el método *next* en el objeto *iterador* creado cuando invocamos nuestra *función generadora*. Las *promesas*, por otro lado, nos permiten especificar *funciones callback* que serán ejecutadas en el caso de que obtengamos los datos "prometidos" o una *función callback* que será ejecutada en caso de que algún error suceda.
La idea es combinar las *funciones generadoras* y las *promesas* en la siguiente forma: Ponemos el código que realiza computaciones asincrónicas dentro de una *función generadora* y ejecutamos dicha función. Cuando alcancemos cierto punto en la ejecución de nuestra *función generadora* que realice una operación asincrónica, creamos una *promesa* que represente el valor de esa operación. Debido a que no tenemos idea de cuando será resuelta dicha *promesa* (o si será resuelta), en este punto de la ejecución de la *función generadora*, pausamos su ejecución utilizando la palabra *yield* para no bloquear la ejecución de nuestro código. Después de un tiempo, cuando la *promesa* ya haya retornado un valor, continuamos la ejecución de nuestro código invocando el método *next* del objeto *iterador*.

```js
//Pasamos una función generadora como argumento a la función async
async(function*() {
    try {
        /*Usamos yield en cada llamada asincrónica para pausar la ejecución de la función generadora hasta que obtengamos un valor*/
        const data = yield obtenerJSON('data.json');
        const data1 = yield obtenerJSON('data1.json');
        const data2 = yield obtenerJSON('data3.json');
    } catch(e) {
        //Manejamos el error
    }
});

function async(generadora) {
    const iterador = generadora(); //Creamos un objeto iterador al invocar la función generadora

    //Función que manejará el resultado de cada invocación del método next de la función generadora 
    function manejar(resultado) {
        //Si el valor de la propiedad done del iterador es true significa que la función generadora ya finalizó su ejecución
        if (iterador.done) { return; }

        //Almacenamos el valor actual del iterador
        const valorDelIterador = iterador.value;

        //Si el valor actual del iterador es una promesa, ejecutamos el método then
        if (valorDelIterador instanceof Promise) {
            //Llamamos la función manejar que invocará el método next con los datos recibidos (para que se los pase a la siguiente promesa)
            valorDelIterador.then(data => manejar(iterador.next(data)))
                            .catch(err => iterador.throw(err));
        }
    }

    try {
        manejar(iterador.next())
    } catch(e) {
        iterador.throw(e);
    }
}
```

La función **async** recibe una *función generadora*, la invoca y crea un objeto *iterador* que usaremos para reanudad la ejecución de dicha función. Dentro de la función **async** declaramos otra función **manejar**, que se encargará el valor que retorne de cada iteración echa en la *funcion generadora*. Si el resultado de la *función generadora* es una *promesa* que es resuelta satisfactoriamente, usamos el método *next* del *iterador* para enviar el resultado de la *promesa* de nuevo a la *función generadora* y reanudar la ejecución. Si un error ocurre y la *promesa* es rechazada, retornamos ese error a la *función generadora* usando el método *throw* en el objeto *iterador*. Seguimos haciendo esto hasta que la *función generadora* ya no tenga valores para retornar o retorne algún error.

Ahora, en la primera invocación al método *next* de la *función generadora*, esta ejecuta la primera llamada a **obtenerJSON**. Esta llamada crea una *promesa* que eventualmente contendrá datos. Debido a que este valor es pedido de forma asincrónica, no sabemos cuanto tiempo vaya a tardar en navegador en obtener una respuesta. Pero si sabemos que no queremos bloquear la ejecución de nuestra aplicación mientras esperamos. Por esta razón, en ese momento de la ejecucón, pausamos la ejecución de la *función generadora* utilizando la palabra *yield* y retornamos el flujo de control a la invocación de la función **manejar**, como el valor que obtuvimos de la *función generadora* es una *promesa*, en la función **manejar** podemos utilizar los métodos *then* y *catch* para registrar *funciones callback* que serán ejecutadas si la *promesa* es resuelta, ya sea satisfactoriamente o no. Con esto, el flujo de control sale de la función **manejar** y del cuerpo de la función **async** y continua con el siguiente código (en nuestro caso no hay ninguno). Durante este tiempo, nuestra *función generadora* esta suspendida y esperando a que recibamos los datos, sin bloquear la ejecución de nuestro programa. Cuando el navegador reciba una respuesta (ya sea satisfactoria o no), una de las *funciones callback* registradas en el método *then* o *catch* es invocada, lo que causa que el método *next* o *throw* del objeto *iterador* de la *función generadora* sea ejecutado y reanude la ejecución de dicha (ya sea para pedirle otro valor o para retornar un error). Si la *función generadora* sigue ejecutandose satisfactoriamente, recibe los valores recibidos de la *promesa* y pasados al método *next*, lo que hace que el primer *yield* sea reemplazado por dichos datos y ahora esten almacenados en la variable **data**. Este proceso se repite hasta que ya no quede más código por ejecutar o suceda algún error.

### Función *async*

Hemos visto que tuvimos que crear una función llamada **async** que se encarga de manejar nuestras *promesas* y pedir valores a la *función generadora*. Podemos escribir esta función una vez y reusarla en todo nuestro código, pero sería mejor si no tuviesemos ni que pensar en escribir una función de este estilo. Es por esto que las personas a cargo de JavaScript, que están al tanto de el buen uso que se le puede dar a la convinación de *promesas* y *funciones generadoras*, han creado dos palabras reservadas nativas de JavaScript que nos permitiran manejar operaciones asincrónicas de forma más sencilla.
Estos palabras reservadas son *async* y *await*. Pronto podremos escribir código de la siguiente manera:

```js
(async function() {
    try {
        const data = await obtenerJSON('data.json');
        const data1 = await obtenerJSON('data1.json');
    } catch(e) {
        console.log(e);
    }
})();
```

Usamos la palabra *async* frente a la palabra *función* para especificar que esa función depende de valores asincrónicos y en cada tarea en la que necesitemos realizar llamadas asincrónicas, ponemos la palabra reservada *await* para especificarle al motor de JavaScript que debe esperar que la ejecución de ese código termine para continuar con la ejecución del siguiente código dentro de la función *async* y todo sin bloquear la ejecución de nuestro programa.

## Resumen

+ Las *funciones generadoras* son funciones que generan una secuencia de valores - no todos a la vez, si no sobre cada solicitud.
+ A diferencia de las funciones estándar, las *funciones generadoras* pueden suspender su ejecución sin bloquear la ejecución de nuestro programa y puede esperar la invocación del método *next* para reanudar su ejecución.
+ Una *función generadora* es declarada al poner un * al lado de la palabra *función*. Dentro de la función, podemos utilizar la palabra *yield* para retornar un valor y suspender la ejecución de la *función generadora*. Si queremos pausar la ejecución y retornar otra *función generadora*, utilizamos la palabra *yield* seguida de un *.
+ Invocar una *función generadora* no la ejecuta, si no que crea un objeto *iterador* que nos permite manejar la ejecución de dicha *función generadora*. Pedimos nuevos valores de la *función generadora* invocando el método *next* del objeto *iterador* y podemos devolver errores usando el método *throw* en el objeto *iterador*. Adicionalmente, el método *next* también puede ser usado para enviar valores a la *función generadora*.
+ Una *promesa* es un espacio reservado para un resultado de una operación asincrónica; está garantizado que obtendremos un valor. Una *promesa* puede terminar su ejecución de forma satisfactoria o fallar.
+ Las *promesas* simplifican significantemente la forma en que manejamos operaciónes asincrónicas y errores. Podemos trabajar de forma sencilla con una secuencia de llamadas asincrónicas concatenando métodos *then*. También podemos ejecutar una serie de operaciones asincrónicas en paralelo utilizando el método *Promise.all*.
+ Podemos convinar *funciones generadoras* y *promesas* para manejar tareas asincrónicas con la simplicidad de código sincrónico.