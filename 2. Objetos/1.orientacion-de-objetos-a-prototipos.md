# Orientación de objetos a *prototipos*

Un *prototipo* al cual se le puede delegar la búsqueda de alguna propiedad. Los *prototipos* son una forma conveniente de definir propiedades que pueden ser automaticamente accesibles por otros objetos. Los *prototipos* tienen el mismo propósito que las *clases* en lenguajes orientados a objetos con clase. De hecho, el uso principal de los *prototipos* en JavaScript es el de producir código escrito de manera orientada a objetos y que sea lo más parecido a lenguajes basados en clase como C# o Java.

## Entendiendo los *prototipos*

En JavaScript, los objetos son colecciones de propiedades con nombre y valores. Por ejemplo, podemos crear nuevos objetos usando la notación literal-objeto:

```js
let obj = {
    prop1: 1, //propiedad con un valor simple
    prop2: function() {}, //propiedad con una función como valor
    prop3: {} //propiedad con otro objeto
};
```

Como podemos ver, las propiedades de los objetos pueden ser valores simples (como números o strings), funciones y otros objetos. Adicinalmente, como JavaScript es un lenguaje altamente dinámico, las propiedades asignadas al objeto pueden ser facilmente modificadas o borradas e incluso podemos asignarle nuevas propiedades a objetos ya creados.

```js
obj.prop1 = function() {}; //modificamos el valor de prop1
obj.prop2 = {}; //modificamos el valor de prop2
obj.prop3 = 3; //modificamos el valor de prop3
obj.prop4 = 'Hemos agregado una propiedad nueva al objeto'; //agregamos una propiedad al objeto

delete obj.prop3; //borramos la propiedad prop3
```

Cuando desarrollamos software, intentamos no reinventar la rueda, queremos reusar tanto código como sea posible. Una forma de reusar y organizar nuestro código es la de utilizar *herencia*, extendiendo las características de un objeto a otro. En JavaScript, la *herencia* es aplicada usando  *prototipos*.
La idea de los *prototipos* es simple. Todos los objetos tienen referencia a su *prototipo*, un objeto al cual puede ser delegada la búsqueda de una propiedad especifica si no se encuentra en el propio objeto dicha propiedad. Es decir, el motor de JavaScript primero busca la propiedad en el objeto como tal, si no la encuentra la busca en el objeto *prototipo*, si no la encuentra la busca en el *prototipo* del *prototipo* y así sucesivamente hasta que la encuentre, si no la encuentra retorna undefined.

```js
//creamos un objeto saludos con una propiedad saludo
const saludos = { saludo: 'Hola' };
//creamos un objeto despedidas con una propiedad despedida
const despedidas = { despedida: 'Chao' };

//utilizamos setPrototypeOf para asignarle el objeto despedidas como prototipo al objeto saludos
Object.setPrototypeOf(saludos, despedidas);
/*buscamos la propiedad despedida (que no existe en el objeto saludo), pero como si existe en el prototipo (el objeto despedidas), es encontrada y retornada*/
console.log(saludos.despedida);
```

En el ejemplo anterior creamos 2 objetos, el objeto saludos y el objeto despedidas, cada propiedad de cada objeto solo es accesible por si mismo. Solo el objeto **saludos** tiene acceso a la propiedad **saludo** y solo el objeto **despedidas** tiene acceso a la propiedad **despedida**.
En JavaScript, el propiedad *prototype* de los objetos es una propiedad interna que no es accesible directamente. El método **Object.setPrototypeOf** acepta 2 argumentos y asigna el segundo objeto como el *prototipo* del primer objeto. Como resultado, cada vez que pidamos la propiedad **despedida** (que debería pertenecer solo al objeto **despedidas**) y no existe en el objeto **saludos**, el motor de JavaScript delega la búsqueda al *prototipo* de dicho objeto y como le hemos asignado el objeto **despedidas** (donde si existe la propiedad **despedida**) como *prototipo* del objeto **saludos**, la propiedad **salud** es encontrada y su valor es retornado.
Es importante hacer énfasis en que todos los objetos pueden tener un *prototipo* y el *prototipo* de un *prototipo* puede tener un *prototipo* y así sucesivamente, creando una cadena de *prototipos*. La delegación de búsqueda de una propiedad puede suceder en toda la cadena de *prototipos* y para la búsqueda cuando ya no hayan más *prototipos* por explorar o haya encontrado la propiedad. En este ejemplo el motor de JavaScript primero busca en el objeto la propiedad **despedida** y como no la consigue, delega la búsqueda al *prototipo* que es donde la encuentra.

## Construcción de objetos y *prototipos*

La forma más sencilla de crear un objeto en JavaScript es la siguiente:

```js
const obj = {};
```

Esto crea un nuevo objeto vacío el cual podemos popular con propiedades

```js
obj.nombre = 'Objeto';
```

Para aquellos que vengan de un lenguaje orientado a objetos pueden notar que falta la encapsulación y estructuración que viene con una constructora de clases, una función que sirve para inicializar un objeto con un estado conocido. Después de todo, si vamos a crear muchas instancias de un objeto del mismo tipo, asignar propiedades a cada uno de los objetos individualmente no es solo tedioso si no que también es propenso a errores. Queremos ser capaces de consolidar las propiedades y métodos de una clase en un solo lugar.
JavaScript provee dicho mecanismo pero de forma diferente a otros lenguajes orientados a objeto. JavaScript ofrece el operador *new* que se utiliza para inicializar un objeto utilizando una *función constructora*, pero no hay una definición verdadera de clases en JavaScript. En lugar, el operador *new*, utilizado en conjunto con una *función constructora*, dispara la creación de un nuevo objeto.
Lo que no hemos aprendido aún es que cada función tiene un *prototipo* que es asignado automaticamente como *prototipo* del objeto creado con esa *función constructora*

```js
function Obj() {} //función que usaremos como constructora
/* Creamos un nuevo método en el prototipo de la función constructora Obj, todos los objetos creados con dicha función compartirán el mismo prototipo y tendrán acceso a este método. */
Obj.prototype.sayHi = function() {
    console.log('Hi');
};

const obj1 = Obj();
obj1.sayHi(); // Cannot read property sayHi of undefined

const obj2 = new Obj();
obj2.sayHi(); // Hey
```

En este código definimos una *función constructora* llamada **Obj** que podemos utilizar para crear nuevos objetos. Sin embargo, cuando ejecutamos la función como una *función normal*, ningún objeto es creado ya que la *función constructora* no retorna ningún valor, por lo que cuando intentamos acceder al método **sayHi** nos devuelve **Cannot read property sayHi of undefined**. Por otro lado, cuando en la variable **obj2** utilizamos el operador *new*, un nuevo objeto es creado e inmediatamente se le asigna el *prototipo* de la *función constructora* como su propio *prototipo*, por lo que ahora tenemos acceso a todas las propiedades del *prototipo* de la *función constructora* **Obj**.

Cuando creamos una función, un nuevo objeto *prototipo* es creado y asignado a esta, dicho objeto *prototipo* solamente contiene una propiedad *constructor* que hace referencia a la *función constructora* (veremos más sobre la propiedad *constructor* más adelante).
Cuando usamos una función como *función constructora* (por ejemplo, invocando **new Obj()**), el *prototipo* del objeto recien creado es el objeto *prototipo* al cual hace referencia la *función constructora*, es decir, al *prototipo* de la *función constructora*.
El *prototipo* de las *funciones constructoras* se puede extender, tanto como con propiedades como con métodos. En el ejemplo anterior extendimos dicho *prototipo* de la siguiente forma:

```js
function Obj() {} //función que usaremos como constructora
//extendemos el prototipo de la función Obj asignandole directamente una propiedad y un valor.
Obj.prototype.sayHi = function() {
    console.log('Hi');
};
```

### Propiedades de instancias

Cuando la *función constructora* es invocada utilizando el operador *new*, su contexto se define como la instancia del objeto nuevo. Además de exponer propiedades a través del *prototipo*, podemos inicializar valores desde la *función constructora* utilizando el parámetro *this*.

```js
function Obj() {
    this.nombre = 'Objeto 1',
    this.sayHi = function() {
        console.log('Hey ' + this.nombre);
    }
}
Obj.prototype.sayHi = function() {
    console.log('Hola ' + this.nombre);
};

const obj1 = new Obj();
obj1.sayHi(); // -> Hey Objecto 1
```

En este caso hemos asignado un método con el mismo nombre tanto dentro de la *función constructora* como en el *prototipo* de la *función constructora*. En este caso JavaScript ignorará el método asignado a el *prototipo*, ya que primero buscará en las propiedades del objeto y como ahí se encuentra una propiedad llamada **sayHi** no será necesario que delege la busqueda al *prototipo* del objeto.

*Nota: no es recomendable asignar propiedades y métodos en las propiedades y en el prototipo a la vez*

Dentro de la *función constructora*, el parámetro *this* hace referencia al objeto que se crea cuando se utiliza el operado *new* para invocar la *función constructora*, así que todas las propiedades creadas utilizando *this* serán asignadas al objeto recien creado.

Cada instancia de objeto creado al invocar una *función constructora* utilizando el operador *new* obtienen sus propias propiedades. Si tenemos 3 objetos diferentes creados utilizando la misma *función constructora*, todos tendrán sus propias propiedades pero compartiran el mismo *prototipo*, ya que el *prototipo* hace referencia al *prototipo* de la función que creo dicho objeto (y los 3 objetos han sido creados usando la misma *función constructora*). Esto es perfecto ya que si no tuviesemos *prototipos* o se crease un *prototipo* para cada objeto, cada objeto tendría el mismo método una y otra vez. Para pocos objetos esto no es problema, pero si tuviesemos cientos o miles de objetos con un método que hace lo mismo, simplemente nuestro método se estaría repitiendo cientos o miles de veces y solo estaríamos consumiento más memoria. Por este motivo los *prototipos* son muy útiles, ya que nos permiten tener una referencia en donde buscar propiedades y métodos que se comparten entre objetos creados con la misma *función constructora* en vez de tener un método igual que se repita en cada objeto.

